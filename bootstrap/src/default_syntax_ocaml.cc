#include "src/parse/conf_parser.h"
const char* DEFAULT_SYNTAX_OCAML =
    "// supported feature lists -----------------------------------------------------\n"
    "\n"
    "supported_apis = [\"record\", \"generic\"];\n"
    "supported_api_styles = [\"free-form\"];\n"
    "supported_code_models = [\"recursive-functions\"];\n"
    "supported_targets = [\"code\", \"dot\"];\n"
    "supported_features = [\"nested-ifs\", \"bitmaps\", \"case-ranges\",\n"
    "    \"tags\", \"captures\", \"captvars\"];\n"
    "\n"
    "\n"
    "// language-specific options ---------------------------------------------------\n"
    "\n"
    "semicolons = 0;\n"
    "backtick_quoted_strings = 0;\n"
    "single_quoted_strings = 0;\n"
    "indentation_sensitive = 0;\n"
    "wrap_blocks_in_braces = 0;\n"
    "\n"
    "\n"
    "// immutable configurations (command-line only options) ------------------------\n"
    "\n"
    "conf:target = code;\n"
    "conf:code-model = recursive-functions;\n"
    "conf:input-encoding = ascii;\n"
    "conf:date = 1;\n"
    "conf:version = 1;\n"
    "conf:conditions = 0;\n"
    "conf:storable-state = 0;\n"
    "conf:flex-syntax = 0;\n"
    "conf:verbose = 0;\n"
    "conf:line-dirs = 1;\n"
    "\n"
    "\n"
    "// mutable configurations ------------------------------------------------------\n"
    "\n"
    "conf:api = record;\n"
    "conf:api:style = free-form;\n"
    "conf:api:sigil = \"@@\";\n"
    "conf:define:YYGETCOND:naked = 0;\n"
    "conf:define:YYSETCOND:naked = 0;\n"
    "conf:define:YYSETCOND@cond = \"@@\";\n"
    "conf:define:YYGETSTATE:naked = 0;\n"
    "conf:define:YYSETSTATE:naked = 0;\n"
    "conf:define:YYSETSTATE@state = \"@@\";\n"
    "conf:define:YYFILL@len = \"@@\";\n"
    "conf:define:YYFILL:naked = 0;\n"
    "conf:define:YYFN = [\"<undefined-function-name>;<undefined-function-type>\"];\n"
    "conf:yyfn:sep = \";\";\n"
    "conf:variable:yycond = \"yycond\";\n"
    "conf:variable:yyctable = \"yyctable\";\n"
    "conf:variable:yyaccept = \"yyaccept\";\n"
    "conf:variable:yytarget = \"yytarget\";\n"
    "conf:variable:yystate = \"yystate\";\n"
    "conf:variable:yynmatch = \"yynmatch\";\n"
    "conf:variable:yypmatch = \"yypmatch\";\n"
    "conf:variable:yyrecord = \"yyrecord\";\n"
    "conf:variable:yych = \"yych\";\n"
    "conf:variable:yych:conversion = 0;\n"
    "conf:variable:yych:literals = char;\n"
    "conf:variable:yych:emit = (code_model.recursive_functions ? 0 : 1);\n"
    "conf:variable:yybm = \"yybm\";\n"
    "conf:variable:yybm:hex = 0;\n"
    "conf:variable:yyfill = \"\";\n"
    "conf:variable:yystable = \"\"; // deprecated\n"
    "conf:header = \"\";\n"
    "conf:eof = -1;\n"
    "conf:sentinel = -1;\n"
    "conf:yyfill:enable = 1;\n"
    "conf:yyfill:parameter = 1;\n"
    "conf:yyfill:check = 1;\n"
    "conf:tags = 0;\n"
    "conf:tags:prefix = \"yyt\";\n"
    "conf:captures = 0;\n"
    "conf:captvars = 0;\n"
    "conf:posix-captures = 0;\n"
    "conf:posix-captvars = 0;\n"
    "conf:invert-captures = 0;\n"
    "conf:cond:abort = 0; // default case causes [redundant-case] warnings\n"
    "conf:cond:prefix = \"yyc_\";\n"
    "conf:cond:enumprefix = \"YYC_\";\n"
    "conf:cond:divider@cond = \"@@\";\n"
    "conf:cond:goto@cond = \"@@\";\n"
    "conf:state:abort = 1;\n"
    "conf:state:nextlabel = 0;\n"
    "conf:bit-vectors = 0;\n"
    "conf:debug-output = 0;\n"
    "conf:computed-gotos = 0;\n"
    "conf:computed-gotos:threshold = 9;\n"
    "conf:nested-ifs = 0;\n"
    "conf:case-insensitive = 0;\n"
    "conf:case-inverted = 0;\n"
    "conf:case-ranges = 1;\n"
    "conf:unsafe = 0;\n"
    "conf:monadic = 0;\n"
    "conf:encoding:ebcdic = 0;\n"
    "conf:encoding:utf32 = 0;\n"
    "conf:encoding:ucs2 = 0;\n"
    "conf:encoding:utf16 = 0;\n"
    "conf:encoding:utf8 = 0;\n"
    "conf:encoding-policy = ignore;\n"
    "conf:empty-class = match-empty;\n"
    "conf:indent:string = \"    \";\n"
    "conf:indent:top = 0;\n"
    "conf:label:prefix = \"yy\";\n"
    "conf:label:yyfill = \"yyFillLabel\";\n"
    "conf:label:yyloop = \"\";\n"
    "conf:label:yyNext = \"yyNext\";\n"
    "conf:label:start = 0;\n"
    "\n"
    "\n"
    "// mutable code configuration --------------------------------------------------\n"
    "\n"
    "conf:define:YYBACKUP = \"yybackup\";\n"
    "conf:define:YYBACKUPCTX = \"yybackupctx\";\n"
    "conf:define:YYCONDTYPE = \"yycondtype\";\n"
    "conf:define:YYCOPYMTAG = sigil \"{lhs} <- \" sigil \"{rhs};\";\n"
    "conf:define:YYCOPYSTAG = sigil \"{lhs} <- \" sigil \"{rhs};\";\n"
    "conf:define:YYCTYPE = \"char\";\n"
    "conf:define:YYCTXMARKER = (api.record ? yyrecord \".\") \"yyctxmarker\";\n"
    "conf:define:YYCURSOR = (api.record ? yyrecord \".\") \"yycursor\";\n"
    "conf:define:YYDEBUG = \"yydebug\";\n"
    "conf:define:YYFILL = \"yyfill\";\n"
    "conf:define:YYGETACCEPT = sigil \"{var}\";\n"
    "conf:define:YYGETCOND = \"yygetcond\";\n"
    "conf:define:YYGETSTATE = \"yygetstate\";\n"
    "conf:define:YYINPUT = (api.record ? yyrecord \".\") \"yyinput\";\n"
    "conf:define:YYLESSTHAN = \"yylesthan\";\n"
    "conf:define:YYLIMIT = (api.record ? yyrecord \".\") \"yylimit\";\n"
    "conf:define:YYMARKER = (api.record ? yyrecord \".\") \"yymarker\";\n"
    "conf:define:YYMAXFILL = \"yymaxfill\";\n"
    "conf:define:YYMAXNMATCH = \"yymaxnmatch\";\n"
    "conf:define:YYMTAGN = \"yymatgn\";\n"
    "conf:define:YYMTAGP = \"yymtagp\";\n"
    "conf:define:YYPEEK = (api.record ? \"get\" : \"yypeek\");\n"
    "conf:define:YYRESTORE = \"yyrestore\";\n"
    "conf:define:YYRESTORECTX = \"yyrestorectx\";\n"
    "conf:define:YYRESTORETAG = \"yyrestoretag\";\n"
    "conf:define:YYSETACCEPT = sigil \"{var} <- \" sigil \"{val};\";\n"
    "conf:define:YYSETCOND = \"yysetcond\";\n"
    "conf:define:YYSETSTATE = \"yysetstate\";\n"
    "conf:define:YYSHIFT = \"yyshift\";\n"
    "conf:define:YYSHIFTSTAG = \"yyshiftstag\";\n"
    "conf:define:YYSHIFTMTAG = \"yyshiftmtag\";\n"
    "conf:define:YYSKIP = \"yyskip\";\n"
    "conf:define:YYSTAGN = \"yystagn\";\n"
    "conf:define:YYSTAGP = \"yystagp\";\n"
    "conf:tags:expression = (api.record ? yyrecord \".\") sigil;\n"
    "conf:tags:negative = (api.generic ? \"@@\" : \"-1\");\n"
    "conf:cond:divider = \"\";\n"
    "conf:cond:goto = \"\";\n"
    "\n"
    "\n"
    "// code templates --------------------------------------------------------------\n"
    "\n"
    "code:var_local = topindent \"let \" name \" = \" init \" in\" nl;\n"
    "code:var_global = topindent \"let \" name \" = \" init nl;\n"
    "\n"
    "code:const_local = topindent \"let \" name \" = \" init \" in\" nl;\n"
    "code:const_global = topindent \"let \" name \" = \" init nl;\n"
    "\n"
    "code:array_local =\n"
    "    topindent \"and \" name \" = [|\" nl indent\n"
    "        [row: topindent [elem{0:-2}: elem \"; \"] [elem{-1}: elem \";\"] nl]\n"
    "    dedent topindent \"|]\" nl;\n"
    "\n"
    "code:array_global = code:array_local;\n"
    "\n"
    "code:array_elem = array \".(\" index \")\";\n"
    "\n"
    "code:type_int = \"int\";\n"
    "code:type_uint = \"uint\";\n"
    "code:type_cond_enum = (storable_state? \"int\" : \"uint\");\n"
    "code:type_yybm = \"int\";\n"
    "code:type_yytarget = <undefined>;\n"
    "\n"
    "code:assign = topindent lhs \" <- \" rhs \";\" nl;\n"
    "\n"
    "code:cmp_eq = \"==\"; // physical equality, as this is used to compare primitive values\n"
    "code:cmp_ne = \"!=\"; // physical inequality, as this is used to compare primitive values\n"
    "code:cmp_lt = \"<\";\n"
    "code:cmp_gt = \">\";\n"
    "code:cmp_le = \"<=\";\n"
    "code:cmp_ge = \">=\";\n"
    "\n"
    "code:if_then_else =\n"
    "    [branch{0}: topindent \"if (\" cond \") then (\" nl\n"
    "        indent [stmt: stmt] dedent]\n"
    "    [branch{1:-1}: topindent \") else \" (have_cond? \"if (\" cond \") then \") \"(\" nl\n"
    "        indent [stmt: stmt] dedent]\n"
    "    topindent \")\" nl;\n"
    "\n"
    "code:if_then_else_oneline =\n"
    "    [branch{0}: topindent \"if (\" cond \") then \" [stmt: stmt] nl]\n"
    "    [branch{1:-1}: topindent \"else \" (have_cond? \"if (\" cond \") then \") [stmt: stmt] nl];\n"
    "\n"
    "code:switch =\n"
    "    topindent \"match \" expr \" with\" nl\n"
    "        indent [case: case] dedent;\n"
    "\n"
    "code:switch_cases =\n"
    "    [case{0:-2}: topindent \"| \" case nl]\n"
    "    [case{-1}:   topindent \"| \" case \" ->\" nl\n"
    "        indent [stmt: stmt] dedent\n"
    "    ];\n"
    "\n"
    "code:switch_cases_oneline =\n"
    "    [case{0:-2}: topindent \"| \" case nl]\n"
    "    [case{-1}:   topindent \"| \" case \" -> \" [stmt: stmt] nl];\n"
    "\n"
    "// In OCaml only literals of type `char` support case ranges.\n"
    "// For `int`, we have to exlicitly list all range values. We cannot use\n"
    "//     `\"c when \" [val{0}: val] \" <= c && c <= \" [val{-1}: val]`\n"
    "// as it causes error when there are multiple cases:\n"
    "//     `Error: Variable c must occur on both sides of this | pattern`.\n"
    "code:switch_case_range = (char_literals\n"
    "    ? [val{0}: val] (many ? \"..\" [val{-1}: val])\n"
    "    : [val{0}: val] [val{1:-1}: \"|\" val]);\n"
    "\n"
    "code:switch_case_default = \"_\";\n"
    "\n"
    "code:enum =\n"
    "    \"type \" name \" = \"\n"
    "        [elem{0}:          elem]\n"
    "        [elem{1:-1}: \" | \" elem]\n"
    "    nl;\n"
    "\n"
    "code:enum_elem = name;\n"
    "\n"
    "code:loop = <undefined>;\n"
    "\n"
    "code:goto = <undefined>;\n"
    "\n"
    "code:fndecl = <undefined>;\n"
    "\n"
    "code:fndef =\n"
    "    name [arg: \" (\" argname \" : \" argtype \")\"] \" : \" type \" =\" nl\n"
    "        indent [stmt: stmt] dedent;\n"
    "\n"
    "code:fncall =\n"
    "    topindent (have_retval ? \"let \" retval \" = \")\n"
    "        \"(\" name \" [@tailcall])\" (have_args ? [arg: \" \" arg] : \" ()\") nl;\n"
    "\n"
    "code:tailcall = topindent \"(\" name \" [@tailcall])\" (have_args ? [arg: \" \" arg] : \" ()\") nl;\n"
    "\n"
    "code:recursive_functions =\n"
    "    [fn{0}:    \"let rec \" fndef nl]\n"
    "    [fn{1:-1}: \"and \"     fndef nl];\n"
    "\n"
    "code:fingerprint =\n"
    "    \"(* Generated by re2ocaml\" (have_version? \" \" version) (have_date? \" on \" date) \" *)\" nl;\n"
    "\n"
    "code:line_info = \"#\" line \" \\\"\" file \"\\\"\" nl;\n"
    "\n"
    "code:abort = topindent \"raise (Failure \\\"internal lexer error\\\")\" nl;\n"
    "\n"
    "code:yydebug =\n"
    "    topindent (api.record\n"
    "        ? YYDEBUG \" \" yyrecord\n"
    "        : YYDEBUG\n"
    "    ) nl;\n"
    "\n"
    "code:yypeek =\n"
    "    topindent (api.record\n"
    "        ? \"let \" yych \" = \" YYPEEK \" \" YYINPUT \" \" YYCURSOR \" in\"\n"
    "        : \"let \" yych \" = \" YYPEEK \" in\"\n"
    "    ) nl;\n"
    "\n"
    "code:yyskip =\n"
    "    topindent (api.record\n"
    "        ? YYCURSOR \" <- \" YYCURSOR \" + 1;\"\n"
    "        : YYSKIP\n"
    "    ) nl;\n"
    "\n"
    "code:yybackup =\n"
    "    topindent (api.record\n"
    "        ? YYMARKER \" <- \" YYCURSOR \";\"\n"
    "        : YYBACKUP\n"
    "    ) nl;\n"
    "\n"
    "code:yybackupctx =\n"
    "    topindent (api.record\n"
    "        ? YYCTXMARKER \" <- \" YYCURSOR \";\"\n"
    "        : YYBACKUPCTX\n"
    "    ) nl;\n"
    "\n"
    "code:yyskip_yypeek = <undefined>;\n"
    "code:yypeek_yyskip = <undefined>;\n"
    "code:yyskip_yybackup = <undefined>;\n"
    "code:yybackup_yyskip = <undefined>;\n"
    "code:yybackup_yypeek = <undefined>;\n"
    "code:yyskip_yybackup_yypeek = <undefined>;\n"
    "code:yybackup_yypeek_yyskip = <undefined>;\n"
    "\n"
    "code:yyrestore =\n"
    "    topindent (api.record\n"
    "        ? YYCURSOR \" <- \" YYMARKER \";\"\n"
    "        : YYRESTORE\n"
    "    ) nl;\n"
    "\n"
    "code:yyrestorectx =\n"
    "    topindent (api.record\n"
    "        ? YYCURSOR \" <- \" YYCTXMARKER \";\"\n"
    "        : YYRESTORECTX\n"
    "    ) nl;\n"
    "\n"
    "code:yyrestoretag =\n"
    "    topindent (api.record\n"
    "        ? YYCURSOR \" <- \" tag \";\"\n"
    "        : YYRESTORETAG\n"
    "    ) nl;\n"
    "\n"
    "code:yyshift =\n"
    "    topindent (api.record\n"
    "        ? YYCURSOR \" <- \" YYCURSOR \" - \" offset \";\"\n"
    "        : YYSHIFT\n"
    "    ) nl;\n"
    "\n"
    "code:yyshiftstag =\n"
    "    topindent (nested ? \"if \" tag \" <> \" neg \" then \") (api.record\n"
    "        ? tag \" <- \" tag \" - \" offset \";\"\n"
    "        : YYSHIFTSTAG\n"
    "    ) nl;\n"
    "\n"
    "code:yyshiftmtag =\n"
    "    topindent YYSHIFTMTAG nl;\n"
    "\n"
    "code:yystagp =\n"
    "    topindent (api.record\n"
    "        ? tag \" <- \" YYCURSOR \";\"\n"
    "        : YYSTAGP\n"
    "    ) nl;\n"
    "\n"
    "code:yymtagp =\n"
    "    topindent YYMTAGP nl;\n"
    "\n"
    "code:yystagn =\n"
    "    topindent (api.record\n"
    "        ? tag \" <- \" neg \";\"\n"
    "        : YYSTAGN\n"
    "    ) nl;\n"
    "\n"
    "code:yymtagn =\n"
    "    topindent YYMTAGN nl;\n"
    "\n"
    "code:yycopystag =\n"
    "    topindent (api.record\n"
    "        ? lhs \" <- \" rhs \";\"\n"
    "        : YYCOPYSTAG\n"
    "    ) nl;\n"
    "\n"
    "code:yycopymtag =\n"
    "    topindent (api.record\n"
    "        ? lhs \" <- \" rhs \";\"\n"
    "        : YYCOPYMTAG\n"
    "    ) nl;\n"
    "\n"
    "code:yygetaccept =\n"
    "    (api.record ? yyrecord \".\" var : YYGETACCEPT);\n"
    "\n"
    "code:yysetaccept =\n"
    "    topindent (api.record\n"
    "        ? yyrecord \".\" var \" <- \" val \";\"\n"
    "        : YYSETACCEPT\n"
    "    ) nl;\n"
    "\n"
    "code:yygetcond =\n"
    "    (api.record ? yyrecord \".\" var : YYGETCOND);\n"
    "\n"
    "code:yysetcond =\n"
    "    topindent (api.record\n"
    "        ? yyrecord \".\" var \" <- \" val \";\"\n"
    "        : YYSETCOND\n"
    "    ) nl;\n"
    "\n"
    "code:yygetstate =\n"
    "    (api.record ? yyrecord \".\" var : YYGETSTATE);\n"
    "\n"
    "code:yysetstate =\n"
    "    topindent (api.record\n"
    "        ? yyrecord \".\" var \" <- \" val \";\"\n"
    "        : YYSETSTATE\n"
    "    ) nl;\n"
    "\n"
    "code:yylessthan =\n"
    "    (api.record\n"
    "        ? (many\n"
    "            ? \"(\" YYLIMIT \" - \" YYCURSOR \") < \" need\n"
    "            : YYLIMIT \" <= \" YYCURSOR)\n"
    "        : YYLESSTHAN);\n"
    "\n"
    "code:yybm_filter = yych \" land ~0xFF\";\n"
    "\n"
    "code:yybm_match = \"(\" yybm \".(\" offset \" + Char.code \" yych \") land \" mask \") != 0\";\n"
    ;
