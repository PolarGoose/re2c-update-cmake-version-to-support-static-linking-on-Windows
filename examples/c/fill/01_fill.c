/* Generated by re2c */
#line 1 "c/fill/01_fill.re"
// re2c $INPUT -o $OUTPUT
#include <assert.h>
#include <stdio.h>
#include <string.h>

#define BUFSIZE 4095

struct Input {
    FILE *file;
    char buffer[BUFSIZE + 1]; // +1 for sentinel
    char *yylimit;
    char *yycursor;
    char *yymarker;
    char *token;
    bool eof;
};

static int fill(Input &in) {
    if (in.eof) return 1;

    const size_t shift = in.token - in.buffer;
    const size_t used = in.yylimit - in.token;

    // Error: lexeme too long. In real life could reallocate a larger buffer.
    if (shift < 1) return 2;

    // Shift buffer contents (discard everything up to the current token).
    memmove(in.buffer, in.token, used);
    in.yylimit -= shift;
    in.yycursor -= shift;
    in.yymarker -= shift;
    in.token -= shift;

    // Fill free space at the end of buffer with new data from file.
    in.yylimit += fread(in.yylimit, 1, BUFSIZE - used, in.file);
    in.yylimit[0] = 0;
    in.eof = in.yylimit < in.buffer + BUFSIZE;
    return 0;
}

static int lex(Input *yyrecord) {
    int count = 0;
loop:
    yyrecord->token = yyrecord->yycursor;
    
#line 49 "c/fill/01_fill.c"
{
	char yych;
yyFillLabel0:
	yych = *yyrecord->yycursor;
	switch (yych) {
		case ' ': goto yy3;
		case '\'': goto yy5;
		default:
			if (yyrecord->yylimit <= yyrecord->yycursor) {
				if (fill(*yyrecord) == 0) goto yyFillLabel0;
				goto yy10;
			}
			goto yy1;
	}
yy1:
	++yyrecord->yycursor;
yy2:
#line 53 "c/fill/01_fill.re"
	{ return -1; }
#line 69 "c/fill/01_fill.c"
yy3:
	++yyrecord->yycursor;
yyFillLabel1:
	yych = *yyrecord->yycursor;
	switch (yych) {
		case ' ': goto yy3;
		default:
			if (yyrecord->yylimit <= yyrecord->yycursor) {
				if (fill(*yyrecord) == 0) goto yyFillLabel1;
			}
			goto yy4;
	}
yy4:
#line 56 "c/fill/01_fill.re"
	{ goto loop; }
#line 85 "c/fill/01_fill.c"
yy5:
	++yyrecord->yycursor;
	yyrecord->yymarker = yyrecord->yycursor;
yyFillLabel2:
	yych = *yyrecord->yycursor;
	if (yych >= 0x01) goto yy7;
	if (yyrecord->yylimit <= yyrecord->yycursor) {
		if (fill(*yyrecord) == 0) goto yyFillLabel2;
		goto yy2;
	}
yy6:
	++yyrecord->yycursor;
yyFillLabel3:
	yych = *yyrecord->yycursor;
yy7:
	switch (yych) {
		case '\'': goto yy8;
		case '\\': goto yy9;
		default:
			if (yyrecord->yylimit <= yyrecord->yycursor) {
				if (fill(*yyrecord) == 0) goto yyFillLabel3;
				goto yy11;
			}
			goto yy6;
	}
yy8:
	++yyrecord->yycursor;
#line 55 "c/fill/01_fill.re"
	{ ++count; goto loop; }
#line 115 "c/fill/01_fill.c"
yy9:
	++yyrecord->yycursor;
yyFillLabel4:
	yych = *yyrecord->yycursor;
	if (yych <= 0x00) {
		if (yyrecord->yylimit <= yyrecord->yycursor) {
			if (fill(*yyrecord) == 0) goto yyFillLabel4;
			goto yy11;
		}
		goto yy6;
	}
	goto yy6;
yy10:
#line 54 "c/fill/01_fill.re"
	{ return count; }
#line 131 "c/fill/01_fill.c"
yy11:
	yyrecord->yycursor = yyrecord->yymarker;
	goto yy2;
}
#line 57 "c/fill/01_fill.re"

}

int main() {
    const char *fname = "input";
    const char content[] = "'qu\0tes' 'are' 'fine: \\'' ";

    // Prepare input file: a few times the size of the buffer, containing
    // strings with zeroes and escaped quotes.
    FILE *f = fopen(fname, "w");
    for (int i = 0; i < BUFSIZE; ++i) {
        fwrite(content, 1, sizeof(content) - 1, f);
    }
    fclose(f);
    int count = 3 * BUFSIZE; // number of quoted strings written to file

    // Initialize lexer state: all pointers are at the end of buffer.
    Input in;
    in.file = fopen(fname, "r");
    in.yycursor = in.yymarker = in.token = in.yylimit = in.buffer + BUFSIZE;
    in.eof = 0;
    // Sentinel (at YYLIMIT pointer) is set to zero, which triggers YYFILL.
    in.yylimit[0] = 0;

    // Run the lexer.
    assert(lex(&in) == count);

    // Cleanup: remove input file.
    fclose(in.file);
    remove(fname);
    return 0;
}
