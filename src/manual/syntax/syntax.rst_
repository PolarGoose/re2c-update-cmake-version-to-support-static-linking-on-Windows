A re2c program consists of a sequence of *blocks* intermixed with code in the
target language. Block start and end markers are either ``/*!re2c`` and ``*/``
(suitable for languages that have C-style multiline comments ``/* ... */``, or
``%{`` and ``%}`` (suitable for other languages). Blocks may have optional names
that allow them to be referenced in other parts of the program (named blocks
were added in version 2.2). There are different kinds of blocks:

  ``/*!re2c[:<name>] ... */`` or ``%{[:<name>] ... %}``
    A *global block* contains definitions, configurations, directives and rules.
    re2c compiles regular expressions associated with each rule into a
    deterministic finite automaton, encodes it in the form of conditional jumps
    in the target language and replaces the block with the generated code. Names
    and configurations defined in a global block are added to the global scope
    and become visible to subsequent blocks. At the start of the program the
    global scope is initialized with command-line `options`_.

  ``/*!local:re2c[:<name>] ... */`` or ``%{local[:<name>] ... %}``
    A *local block* is like a global block, but the names and configurations in
    it have local scope (they do not affect other blocks).

  ``/*!rules:re2c[:<name>] ... */`` or ``%{rules[:<name>] ... %}``
    A *rules block* is like a local block, but it does not generate any code by
    itself, nor does it add any definitions to the global scope -- it is meant 
    to be reused in other blocks. This is a way of sharing code (more details in
    the `reusable blocks`_ section). Prior to re2c version 2.2 rules blocks
    required ``-r --reusable`` option.

  ``/*!use:re2c[:<name>] ... */`` or ``%{use[:<name>] ... %}``
    A use block that references a previously defined rules block. If the name is
    specified, re2c looks for a rules blocks with this name. Otherwise the most
    recent rules block is used (either a named or an unnamed one). A use block
    can add definitions, configurations and rules of its own, which are added to
    those of the referenced rules block. Prior to re2c version 2.2 use blocks
    required ``-r --reusable`` option.

  ``!use:<name>;``
    An in-block use directive that merges a previously defined rules block with
    the specified name into the current block. Named definitions, configurations
    and rules of the referenced block are added to the current ones. Conflicts
    between overlapping rules and configurations are resolved in the usual way:
    the first rule takes priority, and the latest configuration overrides the
    preceding ones. One exception is the special rules ``*``, ``$`` and ``<!>``
    for which a block-local definition always takes priority. A use directive
    can be placed anywhere inside of a block, and multiple use directives are
    allowed.

  ``/*!max:re2c[:<name1>[:<name2>...]] ... */`` or ``%{max[:<name1>[:<name2>...]] ... %}``
    A directive that generates ``YYMAXFILL`` definition.
    An optional list of block names specifies which blocks should be included
    when computing ``YYMAXFILL`` value (if the list is empty, all blocks are
    included).
    By default the generated code is a macro-definition for C
    (``#define YYMAXFILL <n>``), or a global variable for Go
    (``var YYMAXFILL int = <n>``). It can be customized with an optional
    configuration ``format`` that specifies a template string where ``@@{max}``
    (or ``@@`` for short) is replaced with the numeric value of ``YYMAXFILL``.

  ``/*!maxnmatch:re2c[:<name1>[:<name2>...]] ... */`` or ``%{maxnmatch[:<name1>[:<name2>...]] ... %}``
    A directive that generates ``YYMAXNMATCH`` definition (it requires
    ``-P --posix-captures`` option).
    An optional list of block names specifies which blocks should be included
    when computing ``YYMAXNMATCH`` value (if the list is empty, all blocks are
    included).
    By default the generated code is a macro-definition for C
    (``#define YYMAXNMATCH <n>``), or a global variable for Go
    (``var YYMAXNMATCH int = <n>``). It can be customized with an optional
    configuration ``format`` that specifies a template string where ``@@{max}``
    (or ``@@`` for short) is replaced with the numeric value of ``YYMAXNMATCH``.

  ``/*!stags:re2c[:<name1>[:<name2>...]] ... */``, ``/*!mtags:re2c[:<name1>[:<name2>...]] ... */`` or ``%{stags[:<name1>[:<name2>...]] ... %}``, ``%{mtags[:<name1>[:<name2>...]] ... %{``
    Directives that specify a template piece of code that is expanded for each
    s-tag/m-tag variable generated by re2c.
    An optional list of block names specifies which blocks should be included
    when computing the set of tag variables (if the list is empty, all blocks
    are included).
    There are two optional configurations: ``format`` and ``separator``.
    Configuration ``format`` specifies a template string where ``@@{tag}`` (or
    ``@@`` for short) is replaced with the name of each tag variable.
    Configuration ``separator`` specifies a piece of code used to join the
    generated ``format`` pieces for different tag variables.

  ``/*!getstate:re2c[:<name1>[:<name2>...]] ... */`` or ``%{getstate[:<name1>[:<name2>...]] ... %}``
    A directive that generates conditional dispatch on the lexer state (it
    requires ``--storable-state`` option).
    An optional list of block names specifies which blocks should be included in
    the state dispatch. The default transition goes to the start label of the
    first block on the list. If the list is empty, all blocks are included, and
    the default transition goes to the first block in the file that has a start
    label.
    This directive is incompatible with the ``--loop-switch`` option and Rust,
    as it requires cross-block transitions that are unsupported without the
    ``goto`` statement.

  ``/*!conditions:re2c[:<name1>[:<name2>...]] ... */``, ``/*!types:re2c... */`` or ``%{conditions[:<name1>[:<name2>...]] ... %}``, ``%{types... %}``
    A directive that generates condition enumeration (it requires
    ``--conditions`` option).
    An optional list of block names specifies which blocks should be included
    when computing the set of conditions (if the list is empty, all blocks are
    included).
    By default the generated code is an enumeration ``YYCONDTYPE``. It can be
    customized with optional configurations ``format`` and ``separator``.
    Configuration ``format`` specifies a template string where ``@@{cond}`` (or
    ``@@`` for short) is replaced with the name of each condition, and
    ``@@{num}`` is replaced with a numeric index of that condition.
    Configuration ``separator`` specifies a piece of code used to join the
    generated ``format`` pieces for different conditions.

  ``/*!include:re2c <file> */`` or ``%{include <file> %}``
    This directive allows one to include ``<file>``, which must be a double-quoted
    file path. The contents of the file are literally substituted in place of
    the directive, in the same way as ``#include`` works in C/C++. This
    directive can be used together with the ``--depfile`` option to generate
    build system dependencies on the included files.

  ``!include <file>;``
    This directive is the same as ``/*!include:re2c <file> */``, except that it
    should be used inside of a re2c block.

  ``/*!header:re2c:on*/`` or ``%{header:on %}``
    This directive marks the start of header file. Everything after it and up to
    the following ``/*!header:re2c:off*/`` directive is processed by re2c and
    written to the header file specified with ``-t --type-header`` option.

  ``/*!header:re2c:off*/`` or ``%{header:off %}``
    This directive marks the end of header file started with
    ``/*!header:re2c:on*/``.

  ``/*!ignore:re2c ... */`` or ``%{ignore:re2c ... %}``
    A block which contents are ignored and removed from the output file.

A block may contain the following kinds of statements:

  ``<name> = <regular expression>;``
    A *definition* binds a name to a regular expression. Names may contain
    alphanumeric characters and underscore. The `regular expressions`_ section
    gives an overview of re2c syntax for regular expressions. Once defined, the
    name can be used in other regular expressions and in rules. Recursion in
    named definitions is not allowed, and each name should be defined before it
    is used. A block inherits named definitions from the global scope.
    Redefining a name that exists in the current scope is an error.

  ``<configuration> = <value>;``
    A *configuration* allows one to change re2c behavior and customize the
    generated code. For a full list of configurations supported by re2c see the
    `configurations`_ section. Depending on a particular configuration, the
    value can be a keyword, a nonnegative integer number or a one-line string
    which should be enclosed in double or single quotes unless it consists of
    alphanumeric characters. A block inherits configurations from the global
    scope and may redefine them or add new ones. Configurations defined inside
    of a block affect the whole block, even if they appear at the end of it.

  ``<regular expression> { <code> }``
    A *rule* binds a regular expression to a semantic action (a block of code in
    the target language). If the regular expression matches, the associated
    semantic action is executed. If multiple rules match, the longest match
    takes precedence. If multiple rules match the same string, the earliest one
    takes precedence. There are two special rules: the default rule ``*`` and
    the end of input rule ``$``. The default rule should always be defined, it
    has the lowest priority regardless of its place in the block, and it matches
    any code unit (not necessarily a valid character, see the
    `encoding support`_ section). The end of input rule should be defined if the
    corresponding method for `handling the end of input`_ is used. If
    `start conditions`_ are used, rules have more complex syntax.

  ``!<directive>;``
    A *directive* is one of the special predefined statements. Each directive
    has a unique purpose. For example, the ``!use`` directive merges a rules
    block into the current one (see the `reusable blocks`_ section), and the
    ``!include`` directive allows one to include an outer file (see the
    `include files`_ section).

