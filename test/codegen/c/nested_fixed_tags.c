/* Generated by re2c */
// re2c $INPUT -o $OUTPUT -i
#include <assert.h>
#include <stddef.h>





static int lex_tags_generic(const char *str) {
    const char *s = str, *m, *x, *y;
    const char *yyt1;

    
{
	char yych;
	m = s;
	yych = *s;
	switch (yych) {
		case 'b': goto yy2;
		default:
			yyt1 = NULL;
			goto yy1;
	}
yy1:
	y = yyt1;
	x = yyt1;
	yyt1 = NULL;
	if (x != yyt1) x += -1;
	{ return x == NULL ? -1 : (y - x); }
yy2:
	++s;
	yych = *s;
	switch (yych) {
		case 'a': goto yy4;
		default: goto yy3;
	}
yy3:
	s = m;
	yyt1 = NULL;
	goto yy1;
yy4:
	++s;
	yyt1 = s;
	goto yy1;
}

    return -2;
}

static int lex_tags_default(const char *str) {
    const char *YYCURSOR = str, *YYMARKER, *x, *y;
    const char *yyt1;

    
{
	char yych;
	yych = *(YYMARKER = YYCURSOR);
	switch (yych) {
		case 'b': goto yy7;
		default:
			yyt1 = NULL;
			goto yy6;
	}
yy6:
	y = yyt1;
	x = yyt1;
	if (x != NULL) x -= 1;
	{ return x == NULL ? -1 : (y - x); }
yy7:
	yych = *++YYCURSOR;
	switch (yych) {
		case 'a': goto yy9;
		default: goto yy8;
	}
yy8:
	YYCURSOR = YYMARKER;
	yyt1 = NULL;
	goto yy6;
yy9:
	++YYCURSOR;
	yyt1 = YYCURSOR;
	goto yy6;
}

}



#define YYMAXNMATCH 3


static int lex_captures_generic(const char *str) {
    const char *s = str;
    const char *yyt1;
const char *yyt2;

    size_t yynmatch;
    const char* yypmatch[2*YYMAXNMATCH];
    
{
	char yych;
	yych = *s;
	switch (yych) {
		case 'a':
			yyt1 = s;
			goto yy12;
		default:
			yyt1 = s;
			yyt2 = NULL;
			goto yy11;
	}
yy11:
	yynmatch = 3;
	yypmatch[0] = yyt1;
	yypmatch[3] = yyt2;
	yypmatch[5] = yyt2;
	yypmatch[1] = s;
	yypmatch[2] = yyt2;
	yyt2 = NULL;
	if (yypmatch[2] != yyt2) yypmatch[2] += -1;
	yypmatch[4] = yypmatch[2];
	{
        assert(yynmatch == 3);
        return yypmatch[4] == NULL ? -1 : yypmatch[4] - str;
    }
yy12:
	++s;
	yyt2 = s;
	goto yy11;
}

}

static int lex_captures_default(const char *str) {
    const char *YYCURSOR = str;
    const char *yyt1;
const char *yyt2;

    size_t yynmatch;
    const char* yypmatch[2*YYMAXNMATCH];
    
{
	char yych;
	yych = *YYCURSOR;
	switch (yych) {
		case 'a':
			yyt1 = YYCURSOR;
			goto yy15;
		default:
			yyt1 = YYCURSOR;
			yyt2 = NULL;
			goto yy14;
	}
yy14:
	yynmatch = 3;
	yypmatch[0] = yyt1;
	yypmatch[3] = yyt2;
	yypmatch[5] = yyt2;
	yypmatch[1] = YYCURSOR;
	yypmatch[2] = yyt2;
	if (yypmatch[2] != NULL) yypmatch[2] -= 1;
	yypmatch[4] = yypmatch[2];
	{
        assert(yynmatch == 3);
        return yypmatch[4] == NULL ? -1 : yypmatch[4] - str;
    }
yy15:
	++YYCURSOR;
	yyt2 = YYCURSOR;
	goto yy14;
}

}

int main() {
    assert(lex_tags_generic("") == -1);
    assert(lex_tags_generic("ba") == 1);
    assert(lex_tags_default("") == -1);
    assert(lex_tags_default("ba") == 1);
    assert(lex_captures_generic("") == -1);
    assert(lex_captures_generic("a") == 0);
    assert(lex_captures_default("") == -1);
    assert(lex_captures_default("a") == 0);
    return 0;
}
codegen/c/nested_fixed_tags.re:12:21: warning: rule matches empty string [-Wmatch-empty-string]
codegen/c/nested_fixed_tags.re:12:21: warning: rule matches empty string [-Wmatch-empty-string]
codegen/c/nested_fixed_tags.re:44:13: warning: rule matches empty string [-Wmatch-empty-string]
codegen/c/nested_fixed_tags.re:44:13: warning: rule matches empty string [-Wmatch-empty-string]
