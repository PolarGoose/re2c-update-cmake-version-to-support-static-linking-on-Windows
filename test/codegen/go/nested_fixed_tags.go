// Code generated by re2go, DO NOT EDIT.
//go:generate re2go $INPUT -o $OUTPUT -i
package main

func assert_eq(x, y int) { if x != y { panic("error") } }



func lex_tags(str string) int {
	var cur, mar, x, y int
	var yyt1 int
	
{
	var yych byte
	mar = cur
	yych = str[cur]
	switch (yych) {
	case 'b':
		goto yy2
	default:
		yyt1 = -1
		goto yy1
	}
yy1:
	y = yyt1
	x = yyt1
	yyt1 = -1
	if (x != yyt1) {
		x += -1
	}
	{ if x == -1 { return -1 } else { return y - x } }
yy2:
	cur += 1
	yych = str[cur]
	switch (yych) {
	case 'a':
		goto yy4
	default:
		goto yy3
	}
yy3:
	cur = mar
	yyt1 = -1
	goto yy1
yy4:
	cur += 1
	yyt1 = cur
	goto yy1
}

}

const YYMAXNMATCH = 3


func lex_captures(str string) int {
	var cur, yynmatch int
	yypmatch := make([]int, 2*YYMAXNMATCH)
	var yyt1 int
	var yyt2 int
	
{
	var yych byte
	yych = str[cur]
	switch (yych) {
	case 'a':
		yyt1 = cur
		goto yy7
	default:
		yyt1 = cur
		yyt2 = -1
		goto yy6
	}
yy6:
	yynmatch = 3
	yypmatch[0] = yyt1
	yypmatch[3] = yyt2
	yypmatch[5] = yyt2
	yypmatch[1] = cur
	yypmatch[2] = yyt2
	yyt2 = -1
	if (yypmatch[2] != yyt2) {
		yypmatch[2] += -1
	}
	yypmatch[4] = yypmatch[2]
	{
			assert_eq(yynmatch, 3)
			return yypmatch[4]
		}
yy7:
	cur += 1
	yyt2 = cur
	goto yy6
}

}

func main() {
	assert_eq(lex_tags("\000"), -1)
	assert_eq(lex_tags("ba\000"), 1)
	assert_eq(lex_captures("\000"), -1)
	assert_eq(lex_captures("a\000"), 0)
}
codegen/go/nested_fixed_tags.re:23:19: warning: rule matches empty string [-Wmatch-empty-string]
codegen/go/nested_fixed_tags.re:35:11: warning: rule matches empty string [-Wmatch-empty-string]
